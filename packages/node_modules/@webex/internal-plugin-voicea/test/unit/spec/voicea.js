import MockWebex from '@webex/test-helper-mock-webex';
import MockWebSocket from '@webex/test-helper-mock-web-socket';
import {assert} from '@webex/test-helper-chai';
import sinon from 'sinon';
import Mercury from '@webex/internal-plugin-mercury';
import LLMChannel from '@webex/internal-plugin-llm';

import VoiceaService from '@webex/internal-plugin-voicea';
import {EVENT_TRIGGERS} from '@webex/internal-plugin-voicea/src/constants';

describe('plugin-voicea', () => {
  const locusUrl = 'locusUrl';
  const datachannelUrl = 'datachannelUrl';

  describe('voicea', () => {
    let webex, voiceaService;


    beforeEach(() => {
      webex = new MockWebex({
        children: {
          mercury: Mercury,
          llm: LLMChannel,
          voicea: VoiceaService
        },
      });

      voiceaService = webex.internal.voicea;
      voiceaService.connect = sinon.stub().resolves(true);
      voiceaService.request = sinon.stub().resolves({
        headers: {},
        body: ''
      });
      voiceaService.register = sinon.stub().resolves({
        body: {
          binding: 'binding',
          webSocketUrl: 'url'
        }
      });
    });

    describe('#sendAnnouncement', () => {
      beforeEach(async () => {
        await voiceaService.registerAndConnect(locusUrl, datachannelUrl);
        const mockWebSocket = new MockWebSocket();

        voiceaService.socket = mockWebSocket;
      });

      it("sends announcement if voicea hasn't joined", () => {
        voiceaService.sendAnnouncement();
        assert.calledOnceWithExactly(voiceaService.socket.send, {
          id: '1',
          type: 'publishRequest',
          recipients: {route: undefined},
          headers: {},
          data: {
            clientPayload: {
              version: 'v2',
            },
            eventType: 'relay.event',
            relayType: 'client.annc',
          },
          trackingId: sinon.match.string
        });
      });
    });

    describe('#processAnnouncementMessage', () => {
      it('works on non-empty payload', async () => {
        const voiceaPayload = {
          translation: {
            allowed_languages: ['af', 'am'],
            max_languages: 5,
          },
          ASR: {
            spoken_languages: ['en']
          },

          version: 'v2'
        };

        const spy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.VOICEA_ANNOUNCEMENT, spy);
        voiceaService.processAnnouncementMessage(voiceaPayload);
        assert.calledOnceWithExactly(spy, {
          captionLanguages: ['af', 'am'],
          spokenLanguages: ['en'],
          maxLanguages: 5
        });
      });

      it('works on non-empty payload', async () => {
        const spy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.VOICEA_ANNOUNCEMENT, spy);
        await voiceaService.processAnnouncementMessage({});
        assert.calledOnceWithExactly(spy, {
          captionLanguages: [],
          spokenLanguages: [],
          maxLanguages: 0
        });
      });
    });

    describe('#requestLanguage', () => {
      beforeEach(async () => {
        await voiceaService.registerAndConnect(locusUrl, datachannelUrl);
        const mockWebSocket = new MockWebSocket();

        voiceaService.socket = mockWebSocket;
      });

      it('requests caption language', () => {
        voiceaService.requestLanguage('en');

        assert.calledOnceWithExactly(voiceaService.socket.send, {
          id: '1',
          type: 'publishRequest',
          recipients: {route: undefined},
          headers: {to: undefined},
          data: {
            clientPayload: {
              translationLanguage: 'en',
              id: sinon.match.string
            },
            eventType: 'relay.event',
            relayType: 'voicea.transl.req'
          },
          trackingId: sinon.match.string
        });
      });
    });

    describe('#setSpokenLanguage', () => {
      beforeEach(async () => {
        await voiceaService.registerAndConnect(locusUrl, datachannelUrl);
      });

      it('sets spoken language', async () => {
        const languageCode = 'en';
        const triggerSpy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.SPOKEN_LANGUAGE_UPDATE, triggerSpy);
        await voiceaService.setSpokenLanguage(languageCode);

        assert.calledOnceWithExactly(triggerSpy, {languageCode});

        sinon.assert.calledWith(voiceaService.request, sinon.match({
          method: 'PUT',
          url: `${locusUrl}/controls/`,
          body: {languageCode}
        }));
      });
    });

    describe('#turnOnCaptions', () => {
      beforeEach(async () => {
        await voiceaService.registerAndConnect(locusUrl, datachannelUrl);

        const mockWebSocket = new MockWebSocket();

        voiceaService.socket = mockWebSocket;
      });

      it('turns on captions', async () => {
        const announcementSpy = sinon.spy(voiceaService, 'sendAnnouncement');

        const triggerSpy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.CAPTIONS_TURNED_ON, triggerSpy);
        await voiceaService.turnOnCaptions();
        sinon.assert.calledWith(voiceaService.request, sinon.match({
          method: 'PUT',
          url: `${locusUrl}/controls/`,
          body: {transcribe: {caption: true}}
        }));

        assert.calledOnceWithExactly(triggerSpy, undefined);
        assert.calledOnce(announcementSpy);
      });

      it('doesn\'t call API on captions', async () => {
        await voiceaService.turnOnCaptions();

        // eslint-disable-next-line no-underscore-dangle
        voiceaService._emit('event:relay.event', {headers: {from: 'ws'}, voiceaPayload: {}, data: {relayType: 'voicea.annc'}});

        const response = await voiceaService.turnOnCaptions();

        assert.equal(response, undefined);
      });
    });

    describe('#toggleTranscribing', () => {
      beforeEach(async () => {
        await voiceaService.registerAndConnect(locusUrl, datachannelUrl);

        const mockWebSocket = new MockWebSocket();

        voiceaService.socket = mockWebSocket;
      });

      it('turns on transcribing with CC enabled', async () => {
        // Turn on captions
        await voiceaService.turnOnCaptions();
        const announcementSpy = sinon.spy(voiceaService, 'sendAnnouncement');

        // eslint-disable-next-line no-underscore-dangle
        voiceaService._emit('event:relay.event', {headers: {from: 'ws'}, voiceaPayload: {}, data: {relayType: 'voicea.annc'}});

        const triggerSpy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.TRANSCRIBING_ON, triggerSpy);
        await voiceaService.toggleTranscribing(true);
        sinon.assert.calledWith(voiceaService.request, sinon.match({
          method: 'PUT',
          url: `${locusUrl}/controls/`,
          body: {transcribe: {transcribing: true}}
        }));

        assert.calledOnce(triggerSpy);
        assert.notCalled(announcementSpy);
      });

      it('turns on transcribing with CC disabled', async () => {
        const announcementSpy = sinon.spy(voiceaService, 'sendAnnouncement');

        const triggerSpy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.TRANSCRIBING_ON, triggerSpy);
        await voiceaService.toggleTranscribing(true);
        sinon.assert.calledWith(voiceaService.request, sinon.match({
          method: 'PUT',
          url: `${locusUrl}/controls/`,
          body: {transcribe: {transcribing: true}}
        }));

        assert.calledOnce(triggerSpy);
        assert.calledOnce(announcementSpy);
      });

      it('turns off transcribing', async () => {
        await voiceaService.toggleTranscribing(true);

        const announcementSpy = sinon.spy(voiceaService, 'sendAnnouncement');

        const triggerSpy = sinon.spy();

        voiceaService.on(EVENT_TRIGGERS.TRANSCRIBING_OFF, triggerSpy);
        await voiceaService.toggleTranscribing(false);
        sinon.assert.calledWith(voiceaService.request, sinon.match({
          method: 'PUT',
          url: `${locusUrl}/controls/`,
          body: {transcribe: {transcribing: true}}
        }));

        assert.calledOnce(triggerSpy);
        assert.notCalled(announcementSpy);
      });

      it('doesn\'t call API on same value', async () => {
        await voiceaService.toggleTranscribing(true);
        const triggerSpy = sinon.spy();
        const announcementSpy = sinon.spy(voiceaService, 'sendAnnouncement');


        voiceaService.on(EVENT_TRIGGERS.TRANSCRIBING_OFF, triggerSpy);

        await voiceaService.toggleTranscribing(true);

        assert.notCalled(triggerSpy);
        assert.notCalled(announcementSpy);

        sinon.assert.calledTwice(voiceaService.request);
      });
    });
  });
});
