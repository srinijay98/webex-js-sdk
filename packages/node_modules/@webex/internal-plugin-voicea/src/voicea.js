import {Mercury} from '@webex/internal-plugin-mercury';
import {WebexPlugin} from '@webex/webex-core';
import uuid from 'uuid';

import Trigger from '../../plugin-meetings/src/common/events/trigger-proxy.js';

import {EVENT_TRIGGERS} from './constants';

export const config = {
  voicea: {
    /**
     * Milliseconds between pings sent up the socket
     * @type {number}
     */
    pingInterval: process.env.MERCURY_PING_INTERVAL || 15000,
    /**
     * Milliseconds to wait for a pong before declaring the connection dead
     * @type {number}
     */
    pongTimeout: process.env.MERCURY_PONG_TIMEOUT || 14000,
    /**
     * Maximum milliseconds between connection attempts
     * @type {Number}
     */
    backoffTimeMax: process.env.MERCURY_BACKOFF_TIME_MAX || 32000,
    /**
     * Initial milliseconds between connection attempts
     * @type {Number}
     */
    backoffTimeReset: process.env.MERCURY_BACKOFF_TIME_RESET || 1000,
    /**
     * Milliseconds to wait for a close frame before declaring the socket dead and
     * discarding it
     * @type {[type]}
     */
    forceCloseDelay: process.env.MERCURY_FORCE_CLOSE_DELAY || 2000,
  },
};

const VoiceaChannel = Mercury.extend({
  namespace: 'Voicea',

  props: {
    socketUrl: {
      type: 'string',
      required: true,
    },
    binding: {
      type: 'string',
    },
  },

  session: {
    isSharingMercury: {
      type: 'boolean',
      default: false,
    },
    socket: {
      type: 'object',
    },
  },

  /**
   * Initialize plugin
   * @param  {...any} args
   * @returns {function}
   */
  initialize(...args) {
    this.seqNum = 1;
    this.hasVoiceaJoined = false;
    this.areCaptionsEnabled = false;
    this.isTranscribingEnabled = false;
    this.vmcDeviceId = undefined;
    this.on('event:relay.event', (e) => {
      this.seqNum = e.sequenceNumber + 1;
      if (e.data.relayType === 'voicea.annc') {
        this.vmcDeviceId = e.headers.from;
        this.hasVoiceaJoined = true;
        this.processAnnouncementMessage(e.voiceaPayload);
      }
    });

    return Reflect.apply(WebexPlugin.prototype.initialize, this, args);
  },

  /**
 * processes voicea announcement response
 * @param {Object} voiceaPayload
 * @returns {Object}
 */
  processAnnouncementMessage(voiceaPayload) {
    const voiceaLanguageOptions = {
      captionLanguages: voiceaPayload?.translation?.allowed_languages ?? [],
      maxLanguages: voiceaPayload?.translation?.max_languages ?? 0,
      spokenLanguages: voiceaPayload?.ASR?.spoken_languages ?? [],
    };

    Trigger.trigger(
      this,
      {
        file: 'voicea',
        function: 'processAnnouncementMessage'
      },
      EVENT_TRIGGERS.VOICEA_ANNOUNCEMENT,
      voiceaLanguageOptions
    );
  },

  /**
   * Register to the websocket
   * @param {*} locusDataUrl
   * @returns {void}
   */
  register(locusDataUrl) {
    return this.request({
      method: 'POST',
      url: locusDataUrl,
    }).then((res) => {
      this.webSocketUrl = res.body.webSocketUrl;
      this.binding = res.body.binding;
    });
  },

  /**
   * Register and connect to the websocket
   * @param {string} locusUrl
   * @param {string} datachannelUrl
   * @returns {void}
   */
  registerAndConnect(locusUrl, datachannelUrl) {
    this.locusDataUrl = datachannelUrl;
    this.locusUrl = locusUrl;

    return this.register(datachannelUrl).then(async () => {
      this.connect(this.webSocketUrl);
    });
  },

  /**
   * Sends Announcement to add voicea to the meeting
   * @returns {void}
   */
  sendAnnouncement() {
    if (this.hasVoiceaJoined) return;
    this.socket.send({
      id: `${this.seqNum}`,
      type: 'publishRequest',
      recipients: {
        route: this.binding,
      },
      headers: {},
      data: {
        clientPayload: {
          version: 'v2',
        },
        eventType: 'relay.event',
        relayType: 'client.annc',
      },
      trackingId: `WEBCLIENT_${uuid.v4()}`,
    });
    this.seqNum += 1;
  },

  /**
   * Set Spoken Language for the meeting
   * @param {string} languageCode
   * @returns {Promise}
   */
  setSpokenLanguage(languageCode) {
    return this.request({
      method: 'PUT',
      url: `${this.locusUrl}/controls/`,
      body: {
        languageCode
      }
    }).then(() => {
      Trigger.trigger(this, {
        file: 'voicea',
        function: 'setSpokenLanguage'
      },
      EVENT_TRIGGERS.SPOKEN_LANGUAGE_UPDATE,
      {languageCode});
    });
  },

  /**
   * Request Language translation
   * @param {string} languageCode
   * @returns {void}
   */
  requestLanguage(languageCode) {
    this.socket.send({
      id: `${this.seqNum}`,
      type: 'publishRequest',
      recipients: {
        route: this.binding,
      },
      headers: {
        to: this.vmcDeviceId,
      },
      data: {
        clientPayload: {
          translationLanguage: languageCode,
          id: uuid.v4(),
        },
        eventType: 'relay.event',
        relayType: 'voicea.transl.req',
      },
      trackingId: `WEBCLIENT_${uuid.v4()}`,
    });
    this.seqNum += 1;
  },

  /**
   * Turn on Captions
   * @returns {Promise}
   */
  turnOnCaptions() {
    if (this.hasVoiceaJoined && this.areCaptionsEnabled) return false;

    return this.request({
      method: 'PUT',
      url: `${this.locusUrl}/controls/`,
      body: {
        transcribe: {caption: true}
      }
    }).then(() => {
      Trigger.trigger(this, {
        file: 'voicea',
        function: 'turnOnCaptions'
      },
      EVENT_TRIGGERS.CAPTIONS_TURNED_ON);
      this.areCaptionsEnabled = true;
      this.sendAnnouncement();
    });
  },

  /**
   * Toggle transcribing for highlights
   * @param {bool} activate if true transcribing is turned on
   * @returns {Promise}
   */
  toggleTranscribing(activate) {
    if (this.isTranscribingEnabled === activate) return undefined;

    return this.request({
      method: 'PUT',
      url: `${this.locusUrl}/controls/`,
      body: {
        transcribe: {transcribing: activate}
      }
    }).then(() => {
      Trigger.trigger(this, {
        file: 'voicea',
        function: 'toggleTranscribing'
      },
      activate ? EVENT_TRIGGERS.TRANSCRIBING_ON : EVENT_TRIGGERS.TRANSCRIBING_OFF);
      if (activate && !this.areCaptionsEnabled && !this.hasVoiceaJoined) this.turnOnCaptions();
      this.isTranscribingEnabled = activate;
    });
  }

});

export default VoiceaChannel;
