import uuid from 'uuid';

import {EVENT_TRIGGERS} from '@webex/internal-plugin-voicea/src/constants.js';

import LLMChannel from '../../internal-plugin-llm/src/index';
import Trigger from '../../plugin-meetings/src/common/events/trigger-proxy.js';

// eslint-disable-next-line no-unused-vars
import {VoiceaPayload} from './voicea.types';


export const config = {
  voicea: {
    /**
     * Milliseconds between pings sent up the socket
     * @type {number}
     */
    pingInterval: process.env.MERCURY_PING_INTERVAL || 15000,
    /**
     * Milliseconds to wait for a pong before declaring the connection dead
     * @type {number}
     */
    pongTimeout: process.env.MERCURY_PONG_TIMEOUT || 14000,
    /**
     * Maximum milliseconds between connection attempts
     * @type {Number}
     */
    backoffTimeMax: process.env.MERCURY_BACKOFF_TIME_MAX || 32000,
    /**
     * Initial milliseconds between connection attempts
     * @type {Number}
     */
    backoffTimeReset: process.env.MERCURY_BACKOFF_TIME_RESET || 1000,
    /**
     * Milliseconds to wait for a close frame before declaring the socket dead and
     * discarding it
     * @type {[type]}
     */
    forceCloseDelay: process.env.MERCURY_FORCE_CLOSE_DELAY || 2000,
  },
};

/**
 * VoiceaChannel to hold single instance of LLM
 */
export class VoiceaChannel extends LLMChannel {
  private seqNum: number;

  private hasVoiceaJoined: boolean;

  private areCaptionsEnabled: boolean;

  private isTranscribingEnabled:boolean;

  private vmcDeviceId: string;

  /**
   * Initializes Voicea plugin
   * @param {any} args
   */
  constructor(...args) {
    super(...args);
    this.seqNum = 1;
    this.hasVoiceaJoined = false;
    this.areCaptionsEnabled = false;
    this.isTranscribingEnabled = false;
    this.vmcDeviceId = undefined;

    this.on('event:relay.event', (e) => {
      this.seqNum = e.sequenceNumber + 1;
      if (e.data.relayType === 'voicea.annc') {
        this.vmcDeviceId = e.headers.from;
        this.hasVoiceaJoined = true;
        this.processAnnouncementMessage(e.voiceaPayload);
      }
    });
  }


  /**
 * processes voicea announcement response and triggers event
 * @param {Object} voiceaPayload
 * @returns {void}
 */
  processAnnouncementMessage = (voiceaPayload: VoiceaPayload):void => {
    const voiceaLanguageOptions = {
      captionLanguages: voiceaPayload?.translation?.allowed_languages ?? [],
      maxLanguages: voiceaPayload?.translation?.max_languages ?? 0,
      spokenLanguages: voiceaPayload?.ASR?.spoken_languages ?? [],
    };

    Trigger.trigger(
      this,
      {
        file: 'voicea',
        function: 'processAnnouncementMessage'
      },
      EVENT_TRIGGERS.VOICEA_ANNOUNCEMENT,
      voiceaLanguageOptions
    );
  };


  /**
   * Sends Announcement to add voicea to the meeting
   * @returns {void}
   */
  sendAnnouncement = ():void => {
    if (this.hasVoiceaJoined) return;
    this.socket.send({
      id: `${this.seqNum}`,
      type: 'publishRequest',
      recipients: {
        route: this.getBinding(),
      },
      headers: {},
      data: {
        clientPayload: {
          version: 'v2',
        },
        eventType: 'relay.event',
        relayType: 'client.annc',
      },
      trackingId: `WEBCLIENT_${uuid.v4()}`,
    });
    this.seqNum += 1;
  };

  /**
   * Set Spoken Language for the meeting
   * @param {string} languageCode
   * @returns {Promise}
   */
  setSpokenLanguage = (languageCode: string):Promise<void> => this.request({
    method: 'PUT',
    url: `${this.locusUrl}/controls/`,
    body: {
      languageCode
    }
  }).then(() => {
    Trigger.trigger(this, {
      file: 'voicea',
      function: 'setSpokenLanguage'
    },
    EVENT_TRIGGERS.SPOKEN_LANGUAGE_UPDATE,
    {languageCode});
  });

  /**
   * Request Language translation
   * @param {string} languageCode
   * @returns {void}
   */
  requestLanguage = (languageCode: string): void => {
    this.socket.send({
      id: `${this.seqNum}`,
      type: 'publishRequest',
      recipients: {
        route: this.getBinding(),
      },
      headers: {
        to: this.vmcDeviceId,
      },
      data: {
        clientPayload: {
          translationLanguage: languageCode,
          id: uuid.v4(),
        },
        eventType: 'relay.event',
        relayType: 'voicea.transl.req',
      },
      trackingId: `WEBCLIENT_${uuid.v4()}`,
    });
    this.seqNum += 1;
  };

  /**
   * Turn on Captions
   * @returns {Promise}
   */
  turnOnCaptions = (): false | Promise<void> => {
    if (this.hasVoiceaJoined && this.areCaptionsEnabled) return false;

    return this.request({
      method: 'PUT',
      url: `${this.locusUrl}/controls/`,
      body: {
        transcribe: {caption: true}
      }
    }).then(() => {
      Trigger.trigger(this, {
        file: 'voicea',
        function: 'turnOnCaptions'
      },
      EVENT_TRIGGERS.CAPTIONS_TURNED_ON);
      this.areCaptionsEnabled = true;
      this.sendAnnouncement();
    });
  };

  /**
   * Toggle transcribing for highlights
   * @param {bool} activate if true transcribing is turned on
   * @returns {Promise}
   */
  toggleTranscribing = (activate:boolean) => {
    if (this.isTranscribingEnabled === activate) return undefined;

    return this.request({
      method: 'PUT',
      url: `${this.locusUrl}/controls/`,
      body: {
        transcribe: {transcribing: activate}
      }
    }).then(() => {
      Trigger.trigger(this, {
        file: 'voicea',
        function: 'toggleTranscribing'
      },
      activate ? EVENT_TRIGGERS.TRANSCRIBING_ON : EVENT_TRIGGERS.TRANSCRIBING_OFF);
      if (activate && !this.areCaptionsEnabled && !this.hasVoiceaJoined) this.turnOnCaptions();
      this.isTranscribingEnabled = activate;
    });
  };
}

export default VoiceaChannel;
